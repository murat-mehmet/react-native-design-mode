#!/usr/bin/env node

const path = require('path');
const fs = require('fs');
const glob = require('glob');
const prettier = require('prettier');

const cwd = process.cwd();
const supportedExtensions = ['js', 'jsx', 'ts', 'tsx', 'cjs', 'mjs'];

const previewImports = `
import { decorators, parameters, loaders } from './preview';

if (decorators) {
  decorators.forEach((decorator) => context.addDecorator(decorator));
}
if (parameters) {
  context.addParameters(parameters);
}
if (loaders) {
  context.addLoaders(loaders);
}
`;

function normalizeExcludePaths(paths) {
  // automatically convert a string to an array of a single string
  if (typeof paths === 'string') {
    return [paths];
  }

  // ensure the paths is an array and if any items exists, they are strings
  if (Array.isArray(paths) && paths.every((p) => typeof p === 'string')) {
    return paths;
  }

  // when the paths aren't a string or an (empty) array of strings, return
  return undefined;
}

function requireUncached(module) {
  delete require.cache[require.resolve(module)];

  return require(module);
}

function getMain({ configPath }) {
  const fileExtension = getFilePathExtension({ configPath }, 'main');

  if (fileExtension === null) {
    throw new Error('main config file not found');
  }

  const mainPath = path.resolve(cwd, configPath, `main.${fileExtension}`);

  return requireUncached(mainPath);
}
function getFilePathExtension({ configPath }, fileName) {
  for (const ext of supportedExtensions) {
    const filePath = path.resolve(cwd, configPath, `${fileName}.${ext}`);

    if (fs.existsSync(filePath)) {
      return ext;
    }
  }

  return null;
}

function getPreviewExists({ configPath }) {
  return !!getFilePathExtension({ configPath }, 'preview');
}

function ensureRelativePathHasDot(relativePath) {
  return relativePath.startsWith('.') ? relativePath : `./${relativePath}`;
}


function writeRequires({ configPath, absolute = false }) {
  const designerRequiresLocation = path.resolve(cwd, configPath, 'designer.requires.js');

  const mainImport = getMain({ configPath });

  const main = mainImport.default ?? mainImport;

  const excludePaths = main.excludePaths;

  const normalizedExcludePaths = normalizeExcludePaths(excludePaths);

  let configure = '';

  const designerRequires = main.designs.map((specifier) => {
    const paths = glob
      .sync(specifier, {
        cwd: path.resolve(cwd, configPath),
        absolute,
        // default to always ignore (exclude) anything in node_modules
        ignore:
          normalizedExcludePaths !== undefined ? normalizedExcludePaths : ['**/node_modules'],
      })
      .map((designPath) => {
        const pathWithDirectory = path.join(path.resolve(cwd, configPath), designPath);

        const requirePath = absolute
          ? designPath
          : ensureRelativePathHasDot(path.relative(configPath, pathWithDirectory));

        const normalizePathForWindows = (str) =>
          path.sep === '\\' ? str.replace(/\\/g, '/') : str;

        return `require("${normalizePathForWindows(requirePath)}")`;
      });
    return paths;
  }, []);

  const path_obj_str = `[${designerRequires.join(',')}]`;

  configure = `   
      const getDesigns=() => {
          return ${path_obj_str};
      };

      context.configure(getDesigns)
    `;

  fs.writeFileSync(designerRequiresLocation, '');

  const previewExists = getPreviewExists({ configPath });

  let previewJs = previewExists ? previewImports : '';

  const fileContent = `
      /* do not change this file, it is auto generated by design mode. */

      import { context } from 'react-native-design-mode';
      
      context.initialize();

      ${previewJs}

      ${configure}
      
  `;

  const formattedFileContent = prettier.format(fileContent, { parser: 'babel' });

  fs.writeFileSync(designerRequiresLocation, formattedFileContent, {
    encoding: 'utf8',
    flag: 'w',
  });
}

module.exports = { writeRequires }
